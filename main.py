

answers_dict = {
"Տվյալ, Տվյալների բազաներ, տվյալների բազաների կառավարման համակարգեր։":
    "📊 <b>Տվյալ</b>\n\n"
        "Տվյալը տեղեկատվություն է, որը ներկայացվում է ցանկացած ձևով, որը կարող է պահպանվել, մշակվել կամ փոխանցվել: "
        "Տվյալները կարող են լինել թվեր, տեքստեր, պատկերներ, ձայնագրություններ կամ այլ տեսակի ինֆորմացիա, որը կարելի է "
        "օգտագործել վերլուծության, որոշումներ կայացնելու կամ համակարգերի մշակման համար:\n\n"
        "⚙️ <b>SQL Սերվերի Տվյալների Տիպեր</b>\n"
        "1️⃣ Թվային\n"
        "2️⃣ Ամսաթվային\n"
        "3️⃣ Սիմվոլային\n"
        "4️⃣ Բինար\n"
        "5️⃣ Խառը տիպեր\n\n"
        "📂 <b>Տվյալների Բազա (Database)</b>\n"
        "Տեղեկատվության կազմակերպված հավաքածու, որը պահվում է աղյուսակների տեսքով: Այն հեշտացնում է տվյալների պահպանումը, "
        "կառավարումը և որոնումը.\n\n"
        "ℹ️ <b>Հիմնական տարրեր</b>:\n"
        "• Աղյուսակներ՝ տվյալների խմբեր:\n"
        "• Դաշտեր՝ սյունակներ, որոնք պարունակում են տվյալների տեսակները (օր.` անուն, տարի):\n"
        "• Տողեր՝ յուրաքանչյուր միավոր տվյալ:\n"
        "• Հարցումներ՝ տվյալներ ստանալու մեթոդներ:\n\n"
        "Օրինակ՝ ուսանողների բազա, որտեղ գրանցված են անունները, տարիքները և գնահատականները:\n\n"
        "⚡️ <b>Տվյալների Բազաների Կառավարման Համակարգեր (DBMS)</b>\n\n"
        "DBMS-ները ծրագրեր են, որոնք օգտագործվում են տվյալների բազաների ստեղծման, կառավարման և կառավարման համար: "
        "Դրանք թույլ են տալիս տվյալները արդյունավետորեն կազմակերպել, փոփոխել և պահպանել:\n\n"
        "🛠️ <b>Հիմնական DBMS-ներ</b>:\n"
        "1️⃣ <b>Relational DBMS (RDBMS)</b>՝ հարաբերական բազաներ, որոնք օգտագործում են աղյուսակներ (օր.` SQL):\n"
        "- Օրինակներ՝ MySQL, PostgreSQL, Microsoft SQL Server, Oracle DB.\n\n"
        "2️⃣ <b>NoSQL DBMS</b>՝ ոչ հարաբերական բազաներ, որոնք նախատեսված են չկառուցված տվյալների համար:\n"
        "- Օրինակներ՝ MongoDB, Cassandra, Couchbase, Firebase.\n\n"
        "3️⃣ <b>In-memory DBMS</b>՝ տվյալների բազաներ, որոնք տվյալները պահում են օպերատիվ հիշողության մեջ՝ արագության համար:\n"
        "- Օրինակներ՝ Redis, Memcached.\n\n"
        "4️⃣ <b>Cloud DBMS</b>՝ ամպային բազաներ, որոնք հասանելի են ինտերնետի միջոցով:\n"
        "- Օրինակներ՝ Google BigQuery, Amazon Aurora, Azure SQL Database.\n\n"
        "5️⃣ <b>Hierarchical և Network DBMS</b>՝ տվյալների կազմակերպման հիերարխիկ կամ ցանցային մոդելներ:\n"
        "- Օրինակներ՝ IBM IMS, CODASYL.\n\n"
        "✅ <b>Հիմնական առանձնահատկություններ</b>:\n"
        "• Տվյալների անվտանգություն՝ պաշտպանություն չթույլատրված մուտքից:\n"
        "• Հարցումներ՝ SQL կամ այլ լեզուներով:\n"
        "• Կապեր՝ տվյալների միջև կապերի ստեղծում:\n"
        "• Պահպանման արդյունավետություն՝ տվյալների կրկնության նվազեցում:\n\n"
        "DBMS-ները լայնորեն կիրառվում են ֆինանսների, առողջապահության, առևտրի և այլ ոլորտներում:\n",
"Տվյալների բազաների մոդելները։":
"📊 <b>Տվյալների Բազաների Մոդելներ</b>\n\n"
"Տվյալների բազաների մոդելները սահմանում են, թե ինչպես է կազմակերպվում, պահվում և կառավարվում տվյալների բազայի տվյալները: "
"Ահա հիմնական մոդելները՝ համառոտ նկարագրությամբ:\n\n"
"1️⃣ <b>Հիերարխիկ մոդել (Hierarchical Model)</b>\n"
"Տվյալները կազմակերպվում են ծառի կառուցվածքով, որտեղ յուրաքանչյուր ծնող կարող է ունենալ բազմաթիվ երեխաներ, բայց յուրաքանչյուր երեխա ունի միայն մեկ ծնող:\n"
"•	Օրինակ: Կազմակերպության աշխատակիցների ծառի կառուցվածք:\n"
"•	Առավելություն: Արագ որոնում, հստակ կապեր:\n"
"•	Թերություն: Շեղումների դժվար կառավարում:\n\n"
"2️⃣ <b>Ցանցային մոդել (Network Model)</b>\n"
"Տվյալները ներկայացվում են որպես գրաֆ, որտեղ մեկ տարր կարող է կապված լինել մի քանի այլ տարրերի հետ:\n"
"•	Օրինակ: Գիրք-հեղինակ կապ (մեկ գիրք՝ բազմաթիվ հեղինակներ, մեկ հեղինակ՝ բազմաթիվ գրքեր):\n"
"•	Առավելություն: Ակնհայտ կապերի ներկայացում:\n"
"•	Թերություն: Կառավարումը բարդ է:\n\n"
"3️⃣ <b>Հարաբերական մոդել (Relational Model)</b>\n"
"Տվյալները պահվում են աղյուսակներում, որոնք կապված են իրար սյունակների միջոցով:\n"
"•	Օրինակ: Ուսանողների աղյուսակ՝ անուն, ազգանուն, տարիք սյունակներով:\n"
"•	Առավելություն: Ճկունություն, հեշտ հարցումներ (SQL):\n"
"•	Թերություն: Մեծ բազաները կարող են լինել դանդաղ:\n\n"
"4️⃣ <b>Օբյեկտային մոդել (Object-Oriented Model)</b>\n"
"Տվյալները ներկայացվում են որպես օբյեկտներ, որոնք պարունակում են և՛ տվյալներ, և՛ գործողություններ:\n"
"•	Օրինակ: Ծրագրավորման օբյեկտների նմանությամբ կառուցված բազաներ:\n"
"•	Առավելություն: Հարմար է բարդ տվյալների համար:\n"
"•	Թերություն: Ավելի դժվար հասկանալ և կիրառել:\n\n"
"5️⃣ <b>NoSQL մոդելներ (Non-Relational Models)</b>\n"
"Նախատեսված են չկառուցված տվյալների պահպանման համար: Հիմնական տեսակներն են՝\n"
"•	Կոնտեյներային մոդել (Key-Value): Օր.` Redis:\n"
"•	Փաստաթղթային մոդել (Document): Օր.` MongoDB:\n"
"•	Գրաֆային մոդել (Graph): Օր.` Neo4j:\n"
"•	Սյունակային մոդել (Columnar): Օր.` Cassandra:\n"
"•	Առավելություն: Հարմար է մեծածավալ տվյալների համար:\n"
"•	Թերություն: Հարցումների լեզուները կարող են տարբերվել:\n\n"
"Այս մոդելներն ընտրվում են կախված տվյալների բազայի կիրառության նպատակներից ու տվյալների կառուցվածքից.",
    "Տվյալների բազաներին ներկայացվող պահանջները:":
 """
📊 <b>Տվյալների Բազաների Պահանջները</b>

Տվյալների բազաներին ներկայացվող պահանջները նախատեսված են ապահովելու համար դրանց արդյունավետ աշխատանքը, անվտանգությունը և տվյալների հուսալիությունը: Ահա հիմնական պահանջները:

________________________________________
1️⃣ <b>Տվյալների ամբողջականություն (Data Integrity) 🧩</b>
• Տվյալները պետք է լինեն ճիշտ, հուսալի և կոորդինացված:
• Օրինակ: Անհնար է միաժամանակ գրանցել ուսանողի երկու տարբեր նույնականացման համարով.

2️⃣ <b>Տվյալների անվտանգություն (Data Security) 🔒</b>
• Պաշտպանություն չթույլատրված մուտքից:
• Օրինակ: Տվյալները հասանելի են միայն համակարգի հավատարմագրված օգտագործողներին:
• Մեթոդներ:
  o Մուտքի իրավունքների կառավարում 🔑
  o Կոդավորում (Encryption) 🔐

3️⃣ <b>Տվյալների պահպանման և վերականգնման հուսալիություն (Data Reliability and Recovery) 🛡️</b>
• Տվյալները պետք է պահպանվեն այնպես, որ դրանք հնարավոր լինի վերականգնել համակարգի խափանման դեպքում:
• Օրինակ: Պահուստային պատճենների (Backup) առկայություն 📂

4️⃣ <b>Տվյալների հասանելիություն (Data Availability) 🌐</b>
• Տվյալները պետք է միշտ լինեն հասանելի օգտագործողների համար:
• Օրինակ: Առևտրի բազան պետք է աշխատի 24/7՝ առանց ընդհատումների 🕒

5️⃣ <b>Տվյալների ավելցուկայինության նվազեցում (Data Redundancy Minimization) ♻️</b>
• Միևնույն տվյալը պետք է պահվի մեկ անգամ՝ տվյալների կրկնությունից խուսափելու համար:
• Օրինակ: Հասցեն մեկ անգամ է գրանցվում բոլոր հաճախորդների համար 🏠

6️⃣ <b>Տվյալների փոփոխման հեշտություն (Data Modifiability) 🔄</b>
• Պետք է հեշտ լինի տվյալների ավելացումն, փոփոխումն ու ջնջումը:
• Օրինակ: Նոր դասընթաց ավելացնել ուսումնական բազայում 📝

7️⃣ <b>Տվյալների բազմամուտքայնություն (Multi-User Support) 👥</b>
• Միաժամանակ մի քանի օգտագործող պետք է կարողանա մուտք գործել տվյալների բազա՝ առանց խնդիրների:
• Օրինակ: Մի քանի աշխատակից միաժամանակ ավելացնում է պատվերներ 📑

8️⃣ <b>Տվյալների աջակցություն հարցումներին (Query Support) 🔍</b>
• Տվյալների բազան պետք է արագ և արդյունավետ պատասխանի հարցումներին:
• Օրինակ: Հաճախորդների ցուցակն ստանալ ըստ ծննդյան ամսաթվի 🎂

9️⃣ <b>Տվյալների փոխանակելիություն (Data Portability) 📦</b>
• Տվյալների բազան պետք է աջակցի տվյալների տեղափոխումը մեկ համակարգից մյուսը:
• Օրինակ: Տվյալների արտահանում Excel կամ JSON ֆորմատով 📊

🔟 <b>Տվյալների մասշտաբելիություն (Scalability) 📈</b>
• Տվյալների բազան պետք է հեշտությամբ ընդլայնվի՝ մեծ ծավալի տվյալների հետ աշխատելու համար:
• Օրինակ: Միլիոնավոր օգտագործողներով բազան առանց աշխատանքի դանդաղեցման 🚀

Այս պահանջների ապահովումը կարևոր է տվյալների բազայի արդյունավետության և հուսալիության համար ⚙️
"""
,
    "Տվյալների բազաների կառավարման համակարգերում ACID-ը։" :
"""
📊 <b>ACID Սկզբունքը</b> (Atomicity, Consistency, Isolation, Durability) տվյալների բազաների կարևոր հատկություն է, որն ապահովում է տվյալների վստահելիությունը և հուսալիությունը գործարքների (transaction) ընթացքում:

1️⃣ <b>Atomicity (Ատոմականություն) ⚡</b>
Գործարքը կատարվում է ամբողջությամբ կամ ընդհանրապես չի կատարվում:
• Օրինակ: Եթե գումար եք փոխանցում A հաշվից B հաշվի վրա, ապա գումարը պետք է հեռացվի A-ից և ավելացվի B-ում, այլապես գործարքը կվերացվի 🔄
• Առավելություն: Կանխում է տվյալների անավարտ վիճակը 🚫

2️⃣ <b>Consistency (Համապատասխանություն) 📏</b>
Գործարքի կատարումից հետո տվյալների բազան պետք է անցնի ճիշտ վիճակից մեկ այլ ճիշտ վիճակ՝ համապատասխան բիզնես կանոններին:
• Օրինակ: Հաշվի գումարը չի կարող լինել բացասական 💸

3️⃣ <b>Isolation (Առանձնացվածություն) 🛑</b>
Միաժամանակ կատարվող գործարքները պետք է մեկմեկու չխանգարեն, և յուրաքանչյուր գործարքը պետք է կատարվի այնպես, կարծես այն միակն է:
• Օրինակ: Երկու օգտագործող միաժամանակ փորձում են գնել վերջին ապրանքը, բայց միայն մեկը կարող է հաջողությամբ ավարտել գործարքը 🛒

4️⃣ <b>Durability (Հաստատունություն) 💪</b>
Գործարքի ավարտից հետո փոփոխությունները պետք է մշտապես պահպանվեն, նույնիսկ համակարգի խափանման դեպքում:
• Օրինակ: Եթե պատվերը հաստատվել է, այն կմնա բազայում, նույնիսկ եթե սերվերը դադարի աշխատել 🖥️➡️💾

<b>Ինչու է ACID կարեւոր</b>
• Ապահովում է տվյալների հուսալիությունը ✅
• Կանխում է սխալներ և տվյալների կորուստ 🔒
• Հարմար է ֆինանսական, առողջապահական և այլ կարևոր ոլորտների բազաների համար 💰🏥

ACID սկզբունքը հիմնականում կիրառվում է հարաբերական բազաներում (RDBMS), ինչպիսիք են MySQL, PostgreSQL, Oracle, և այլն 🖥️💻
""",
    "Ռելյացիոն բազաներ՝ աղյուսակների հատկանիշները։":
"""
📊 <b>Ռելյացիոն բազաները</b> կազմակերպվում են աղյուսակների միջոցով, որտեղ տվյալները ներկայացվում են տողերով և սյունակներով: Աղյուսակները (տաբլիցաները) ունեն մի շարք հիմնական հատկանիշներ, որոնք ապահովում են դրանց արդյունավետությունը և օգտագործման հեշտությունը:


1️⃣ <b>Աղյուսակի կառուցվածքը 🏗️</b>
• Տողեր (Rows) կամ ռեկորդներ (Records)՝ ներկայացնում են տվյալների անհատական միավորներ:
  o Օրինակ: Ուսանողի տվյալները՝ անուն, ազգանուն, տարիք 👨‍🎓👩‍🎓
• Սյունակներ (Columns) կամ դաշտեր (Fields)՝ սահմանում են տվյալների տեսակները:
  o Օրինակ: Անուն, ազգանուն, տարիք սյունակները 📅📝


2️⃣ <b>Աղյուսակի անուն (Table Name) 🏷️</b>
Յուրաքանչյուր աղյուսակ ունի եզակի անուն, որը թույլ է տալիս նույնականացնել տվյալ աղյուսակը տվյալների բազայում:
• Օրինակ: Students, Orders, Products 🎓📦


3️⃣ <b>Աղյուսակի դաշտերի առանձնահատկություններ ⚙️</b>
• Դաշտերի անուններ՝ յուրահատուկ անուններ, որոնք նույնականացնում են յուրաքանչյուր սյունակ:
  o Օրինակ: FirstName, LastName 🏷️
• Տվյալների տեսակներ՝ յուրաքանչյուր սյունակ ունի որոշակի տվյալների տիպ (օրինակ՝ տեքստ, ամբողջ թիվ, ամսաթիվ):
  o Օրինակ: INT, VARCHAR, DATE 🗓️


4️⃣ <b>Աղյուսակի բանալիներ (Keys) 🔑</b>
• Primary Key (Առաջնային բանալի) 🔒
  Յուրահատուկ դաշտ, որը միանշանակ նույնականացնում է աղյուսակի յուրաքանչյուր տող:
  o Օրինակ: Ուսանողի ID (StudentID) 🎓
• Foreign Key (Օտար բանալի) 🔗
  Դաշտ, որը կապում է մեկ աղյուսակի տողերը մյուս աղյուսակի հետ:
  o Օրինակ: Պատվերի աղյուսակում հաճախորդի ID-ն 🛒


5️⃣ <b>Դաշտերի սահմանափակումներ (Constraints) 🚧</b>
Կանոններ, որոնք ապահովում են տվյալների ամբողջականությունը և հուսալիությունը:
• NOT NULL՝ դաշտը չի կարող լինել դատարկ 🚫
• UNIQUE՝ դաշտը պետք է պարունակի միայն եզակի արժեքներ 🏷️
• CHECK՝ սահմանում է արժեքների ստուգման կանոններ ✅
• DEFAULT՝ սահմանում է դաշտի նախնական արժեք 💼


6️⃣ <b>Տվյալների կարգավորվածություն (Order) 📏</b>
Տողերը աղյուսակում պահվում են անկարգ, բայց կարելի է օգտագործել հարցումների միջոցով տվյալների կարգավորումը:
• Օրինակ: ORDER BY հարցումը 🔄


7️⃣ <b>Հարաբերություններ (Relationships) 🔗</b>
Աղյուսակները կապվում են իրար բանալիների միջոցով՝ ստեղծելով տվյալների ամբողջականություն:
• Օրինակ: Հաճախորդների աղյուսակը կապվում է պատվերների աղյուսակի հետ 📋➡️🛒
""",
    "Ռելյացիոն բազաներում կապերի տեսակները։":
"""
🔗 <b>Ռելյացիոն բազաներում կապերը (relationships)</b> հնարավորություն են տալիս աղյուսակներին կապվել միմյանց հետ, ապահովելով տվյալների ամբողջականություն և կառուցվածքային կազմակերպում: Աղյուսակների միջև կապերի տեսակները հետևյալն են:


1️⃣ <b>1-ը 1-ին (One-to-One) 🧑‍🤝‍🧑</b>
Մեկ աղյուսակի յուրաքանչյուր տող կապվում է միայն մեկ այլ աղյուսակի մեկ տողի հետ:
• Օրինակ:
  o Աղյուսակ 1՝ Employees (Աշխատակիցներ) 🧑‍💼:
  o Աղյուսակ 2՝ EmployeeDetails (Աշխատակիցների մանրամասներ) 📝:
  Յուրաքանչյուր աշխատակից ունի մեկ եզակի անձնագրային տվյալ 🆔:
  Իրականացում:
  • Օգտագործվում է Primary Key և Foreign Key՝ նույն դաշտում 🔑


2️⃣ <b>1-ը շատին (One-to-Many) 🔄</b>
Մեկ աղյուսակի մեկ տող կարող է կապվել մեկ այլ աղյուսակի բազմաթիվ տողերի հետ:
• Օրինակ:
  o Աղյուսակ 1՝ Customers (Հաճախորդներ) 🧑‍🤝‍🧑:
  o Աղյուսակ 2՝ Orders (Պատվերներ) 🛒:
  Յուրաքանչյուր հաճախորդ կարող է ունենալ բազմաթիվ պատվերներ 🧑‍💼➡️🛍️:
  Իրականացում:
  • Աղյուսակ 2-ում ներառվում է Աղյուսակ 1-ի Primary Key որպես Foreign Key 🔑


3️⃣ <b>Շատը շատին (Many-to-Many) 🔀</b>
Մեկ աղյուսակի բազմաթիվ տողեր կարող են կապվել մեկ այլ աղյուսակի բազմաթիվ տողերի հետ:
• Օրինակ:
  o Աղյուսակ 1՝ Students (Ուսանողներ) 🎓:
  o Աղյուսակ 2՝ Courses (Դասընթացներ) 📚:
  Յուրաքանչյուր ուսանող կարող է մասնակցել բազմաթիվ դասընթացների 📘, և յուրաքանչյուր դասընթացին կարող են մասնակցել բազմաթիվ ուսանողներ 🎓🧑‍🎓.
  Իրականացում:
  • Ստեղծվում է միջանկյալ աղյուսակ (junction table) 🔀:
    o Աղյուսակ 3՝ StudentCourses (Ուսանող-Դասընթաց) 📋:
    StudentID (FK) 🎓   CourseID (FK) 📚


4️⃣ <b>Ինքնանույն կապ (Self-Referencing Relationship) 🔄</b>
Աղյուսակի տողերը կապվում են նույն աղյուսակի այլ տողերի հետ:
• Օրինակ:
  o Աղյուսակ՝ Employees (Աշխատակիցներ) 👩‍💼:
  Յուրաքանչյուր աշխատակից կարող է ունենալ մեկ մենեջեր, ով նույնպես աշխատակից է 👨‍💼.
  Իրականացում:
  • Աղյուսակում ստեղծվում է Foreign Key, որը վերաբերում է նույն աղյուսակի Primary Key-ին 🔑


Այս կապերը օգնում են տվյալների բազայի կառույցի նախագծմանը և ապահովում տվյալների փոխկապակցվածությունը 🔗.
""",
    "Նորմալացում, նորմալացման I կանոնը։":
"""
📊 <b>Նորմալացում</b>
Նորմալացումը տվյալների բազայի նախագծման գործընթաց է, որն ուղղված է տվյալների կրկնության (redundancy) նվազեցմանը և տվյալների ամբողջականության (integrity) ապահովմանը: Այն բաժանում է բարդ աղյուսակները ավելի փոքր աղյուսակների և սահմանում կապեր դրանց միջև:

________________________________________
🎯 <b>Նորմալացման նպատակը</b>
1️⃣ Կրճատել տվյալների ավելորդությունը (redundancy) 📉:
2️⃣ Ապահովել տվյալների տրամաբանական կազմակերպումը 📋:
3️⃣ Խուսափել տվյալների աններդաշնակությունից (inconsistency) ❌:
4️⃣ Բարձրացնել տվյալների բազայի արդյունավետությունը 🚀:

1️⃣️⃣ <b>Նորմալացման I կանոնը (First Normal Form - 1NF)</b>
1NF-ը պահանջում է, որ աղյուսակը բավարարի հետևյալ պայմանները:

1️⃣ <b>Ամեն դաշտ պետք է պարունակի միայն մեկ արժեք (Single-valued attributes) 📝:</b>
• Օրինակ: Մի դաշտում չպետք է պահվեն բազմաթիվ արժեքներ, ինչպես՝ «Պատվերներ = 101, 102, 103» 🔢:

2️⃣ <b>Տողերի կարգը չպետք է ազդի տվյալների բովանդակության վրա (Atomic values) ⚙️:</b>
• Տվյալների բոլոր տարրերը պետք է լինեն ատոմար, այսինքն՝ բաժանված առանձին մասերի 🧩:

3️⃣ <b>Յուրաքանչյուր տող պետք է ունենա եզակի նույնականացուցիչ (Primary Key) 🔑:</b>
• Աղյուսակը պետք է ունենա սյունակ, որն առանձնացնում է յուրաքանչյուր տող 🧑‍💻.
""",
    "Նորմալացում, նորմալացման II կանոնը։":
"""
📊 <b>Նորմալացում</b>
Նորմալացումը տվյալների բազայի նախագծման գործընթաց է, որն ուղղված է տվյալների կրկնության (redundancy) նվազեցմանը և տվյալների ամբողջականության (integrity) ապահովմանը: Այն բաժանում է բարդ աղյուսակները ավելի փոքր աղյուսակների և սահմանում կապեր դրանց միջև:


🎯 <b>Նորմալացման նպատակը</b>
1️⃣ Կրճատել տվյալների ավելորդությունը (redundancy) 📉
2️⃣ Ապահովել տվյալների տրամաբանական կազմակերպումը 📋
3️⃣ Խուսափել տվյալների աններդաշնակությունից (inconsistency) ❌
4️⃣ Բարձրացնել տվյալների բազայի արդյունավետությունը 🚀


2️⃣️⃣ <b>Նորմալացում II կանոնը (Second Normal Form - 2NF)</b>
2NF-ը նորմալացման ավելի բարձր մակարդակ է, որն հետևում է առաջին կանոնին (1NF), սակայն ավելացնում է լրացուցիչ պահանջներ՝ վերացնելով որոշակի կախվածությունները:


🎯 <b>2NF-ի պահանջները</b>
1️⃣ <b>Աղյուսակը պետք է լինի 1NF</b> 📝
• Աղյուսակը պետք է համապատասխանի առաջին կանոնին (1NF), այսինքն՝ այն պետք է պարունակի միայն ատոմար արժեքներ, առանց բազմակի արժեքների կամ կրկնվող խմբերի.

2️⃣ <b>Յուրաքանչյուր ոչ բանալի սյունակ պետք է կախված լինի ամբողջությամբ առաջինական բանալիից (Fully Functionally Dependent on the Primary Key) 🔑</b>
• Դա նշանակում է, որ ցանկացած ոչ բանալի սյունակ չի կարող կախված լինել միայն բանալիի մասից (ընդհանուր կախվածություն). Եթե աղյուսակում կա մի քանի բանալի կամ կոմպոզիտային բանալի (մասնակցող մի քանի սյունակ), ապա յուրաքանչյուր ոչ բանալի սյունակ պետք է կախված լինի ամբողջ կոմպոզիտային բանալիից, այլ ոչ թե նրա մասնակի մասերից.


⚠️ <b>Հնարավոր խնդիր 2NF-ում՝ մասակի կախվածություն (Partial Dependency)</b>
• Եթե աղյուսակում մի մասը կազմող բանալիի վրա կախվածություն է առաջանում (մասակի կախվածություն), ապա այն չի համապատասխանում 2NF-ին.
• Մասակի կախվածություն տեղի է ունենում, երբ ոչ բանալի սյունակը կախված է միայն կոմպոզիտային բանալիի մեկ մասից, այլ ոչ թե ամբողջից.
""",
    "Նորմալացում, նորմալացման III կանոնը։":
"""
📊 <b>Նորմալացում</b>
Նորմալացումը տվյալների բազայի նախագծման գործընթաց է, որն ուղղված է տվյալների կրկնության (redundancy) նվազեցմանը և տվյալների ամբողջականության (integrity) ապահովմանը: Այն բաժանում է բարդ աղյուսակները ավելի փոքր աղյուսակների և սահմանում կապեր դրանց միջև:


🎯 <b>Նորմալացման նպատակը</b>
1️⃣ Կրճատել տվյալների ավելորդությունը (redundancy) 📉
2️⃣ Ապահովել տվյալների տրամաբանական կազմակերպումը 📋
3️⃣ Խուսափել տվյալների աններդաշնակությունից (inconsistency) ❌
4️⃣ Բարձրացնել տվյալների բազայի արդյունավետությունը 🚀


3️⃣️⃣ <b>Նորմալացում III կանոնը (Third Normal Form - 3NF)</b>
3NF-ը նորմալացման երրորդ մակարդակն է, որն ավելի խիստ պահանջներ է ներկայացնում տվյալների բազայի կառուցվածքի նկատմամբ, համեմատած 1NF և 2NF հետ: 3NF-ն ունի բարձր մակարդակի ազատություն կախվածություններից՝ ապահովելով տվյալների ամբողջականությունը և նվազեցնելով կրկնություններն ու աններդաշնակությունը:


🎯 <b>3NF-ի պահանջները</b>
1️⃣ <b>Աղյուսակը պետք է լինի 2NF</b> 📝
• Նախքան 3NF-ի ձեռքբերումը, աղյուսակը պետք է համապատասխանի 2NF-ին, այսինքն՝ այն պետք է լինի 1NF և չունենա մասակի կախվածություններ (partial dependencies).

2️⃣ <b>Յուրաքանչյուր ոչ բանալի սյունակ պետք է կախված լինի միայն առաջինական բանալիից և ոչ մի այլ ոչ բանալի սյունակից (Transitive Dependency) 🔄</b>
• Երրորդական կախվածություն (Transitive Dependency) տեղի է ունենում, երբ մի ոչ բանալի սյունակ կախված է մեկ այլ ոչ բանալի սյունակից, որը wiederum կախված է առաջինական բանալիից:
• 3NF-ի պահանջն է, որ ոչ մի ոչ բանալի սյունակ չպետք է կախված լինի մյուս ոչ բանալի սյունակից: Այսինքն՝ եթե A → B և B → C, ապա պետք է լինի A → C, որպեսզի նվազեցվի ավելորդ կախվածությունը.
""",
    "Տվյալներին միաժամանակյա հասնելիության խնդիրներ՝ The Lost Update Problem, The Uncommitted Dependency Problem, the Inconsistent Analysis Problem, The Phantom Read Problem:":
"""
🛑 <b>Տվյալներին միաժամանակյա հասնելիության խնդիրներ</b>
Միաժամանակյա հասանելիություն (Concurrency Control) այն մեթոդներն են, որոնք թույլ են տալիս մի քանի գործարքների կատարում միաժամանակ, առանց տվյալների բազայի ամբողջականության խախտման: Միաժամանակյա հասանելիության խնդիրները առաջանում են, երբ մի քանի գործարքներ (transactions) փորձելու են փոփոխել նույն տվյալները միաժամանակ, ինչը կարող է հանգեցնել սխալների կամ տվյալների անճշտության:


1️⃣ <b>The Lost Update Problem (Կորած թարմացում)</b>
Այս խնդիրն առաջանում է, երբ երկու կամ ավելի գործարքներ միաժամանակ են թարմացնում նույն տվյալները, և մեկը այլևս չի լինի հաշվի առնված:
• Օրինակ:
  - Գործարք 1-ը փակում է դաշտի արժեքը, փոխում այն, բայց դեռ չի կատարել փոփոխությունը տվյալների բազայում:
  - Գործարք 2-ը նաև փոփոխություն է անում նույն դաշտում և կատարում իր փոփոխությունը:
  - Երբ գործարք 1-ը ավարտում է փոփոխությունը, գործարք 2-ի փոփոխությունը ի հայտ է գալիս որպես վերջին փոփոխություն, ինչը կորչում է գործարք 1-ի թարմացումը.
• Անվտանգության լուծում:
  - <b>Locking Mechanisms:</b> Գործարքները պետք է օգտագործեն սեղմում (lock), որպեսզի մեկ գործարք կարողանա միաժամանակ միայն մեկ անգամ փոփոխություն կատարել տվյալների վրա.


2️⃣ <b>The Uncommitted Dependency Problem (Անպահանջ կախվածություն)</b>
Այս խնդիրն առաջանում է, երբ մեկ գործարք կատարում է փոփոխություններ տվյալների վրա, բայց դեռ չի կատարվում commit (ավարտում), իսկ մյուս գործարքը արդեն օգտագործում է այդ տվյալները, ինչը կարող է բերել սխալների:
• Օրինակ:
  - Գործարք 1-ը թարմացնում է տվյալները, բայց դեռ չի կատարել commit.
  - Գործարք 2-ը, որը չի սպասում գործարք 1-ի ավարտին, կատարում է փոփոխություն կամ օգտագործում է նույն տվյալները:
  - Եթե գործարք 1-ը չեղարկվի, ապա գործարք 2-ի գործած տվյալները այլևս անճշտ կլինեն:
• Անվտանգության լուծում:
  - <b>Isolation Levels:</b> Կարգավորվում են մեկուսացման մակարդակները (isolation levels), որոնք թույլ են տալիս գործարքներին փոփոխություններ կատարել միայն այն ժամանակ, երբ մյուսներն արդեն завершены չեն.


3️⃣ <b>The Inconsistent Analysis Problem (Ոչ համատեղ վերլուծություն)</b>
Այս խնդիրն առաջանում է, երբ երկու կամ ավելի գործարքներ միաժամանակ կատարում են տվյալների վերլուծություն (queries), բայց տվյալները փոփոխվում են ընթացքի ժամանակ, ինչը կարող է բերել սխալ արդյունքների:
• Օրինակ:
  - Գործարք 1-ը սկսում է վերլուծություն (query), որը առաջացնում է որոշակի արդյունքներ:
  - Գործարք 2-ը կատարում է փոփոխություններ տվյալների վրա, որոնք ազդեցություն կունենան վերլուծության արդյունքների վրա:
  - Վերլուծությունը ավարտվում է, բայց հաշվի չեն առնվում գործարք 2-ի կատարած փոփոխությունները:
• Անվտանգության լուծում:
  - <b>Repeatable Read:</b> Իզոլացիոն մակարդակների օգտագործումը՝ օրինակ՝ «Repeatable Read» կամ «Serializable», որպեսզի տվյալները չփոխվեն միաժամանակյա գործողությունների ժամանակ.


4️⃣ <b>The Phantom Read Problem (Կրակի ընթերցում)</b>
Այս խնդիրն առաջանում է, երբ մի գործարք կատարում է տվյալների ընթերցում (query), բայց երբ գործարքն ավարտվում է, նոր տվյալներ են ավելացվում կամ փոփոխվում տվյալների բազայում, ինչը կարող է ազդել սկզբնական ընթերցման վրա:
• Օրինակ:
  - Գործարք 1-ը կատարում է հարցում տվյալների բազայից, օրինակ՝ ընտրելով բոլոր պատվերները, որոնց արժեքը բարձր է 100 դրամից:
  - Գործարք 2-ը, որը փոփոխում է տվյալները (օրինակ՝ ավելացնում նոր պատվերներ), ավելացնում է նոր պատվերներ:
  - Երբ գործարք 1-ը կատարում է նույն հարցումը երկրորդ անգամ, այն գտնում է ավելացված նոր պատվերները (phantom rows), ինչը փոփոխում է իր արդյունքը:
• Անվտանգության լուծում:
  - <b>Serializable Isolation Level:</b> Այս մակարդակը թույլ է տալիս գործարքներին փակվել այնպես, որ երբեմն նոր տողեր կամ գրառումներ չեն հայտնվում, ինչը կանխում է ֆանտոմ ընթերցման խնդիրը.
"""
,
    "Արգելափակում։ Արգելափակման մակարդակները։":
    """
    📊 <b>Արգելափակում (Locking) և Արգելափակման Մակարդակները</b>

Արգելափակում (Locking) մեխանիզմները օգտագործվում են տվյալների բազայի համատեղելիության ապահովման համար, երբ մի քանի գործարքներ (transactions) կատարում են գործողություններ տվյալների վրա միաժամանակ: Արգելափակումն ապահովում է, որ միայն մեկ գործարք կարող է փոփոխություններ կատարել տվյալների վրա մեկաժամանակյա իրագործումից: Այս մեխանիզմները թույլ են տալիս կանխել տվյալների չհամապատասխանությունները, միաժամանակյա հասանելիության խնդիրները և այլ սխալներ: Արգելափակման հիմնական նպատակը Isolation մակարդակի ապահովումն է՝ այն հաստատելով, որ յուրաքանչյուր գործարք անխափան իրականացվում է առանց մյուսների միջամտության:


⚙️ <b>Արգելափակման տեսակները</b>

1️⃣ <b>Ձախողման արգելափակում (Exclusive Lock)</b>
- Նպատակ: Արգելափակելու բոլոր մուտքերը տվյալների վրա, բացառությամբ այն գործարքից, որը սեղմում է տվյալները:
- Տեսակ: Գործարքը կարող է միայն գրել տվյալները և չթողնել մյուսներին կատարել որևէ գործողություն (չի թույլատրվում ոչ կարդալ, ոչ գրել տվյալները):
- Օգտագործման դեպքեր: Գրելը կամ թարմացումը պահանջող գործողություններում:
- Օրինակ. Գործարք 1-ը փորձում է թարմացնել տվյալների մեկ դաշտ, բայց մյուս գործարքները չեն կարող կարդալ կամ գրել այդ դաշտում մինչև գործարք 1-ի ավարտը.

2️⃣ <b>Կարդալու արգելափակում (Shared Lock)</b>
- Նպատակ: Տվյալների կարդալու մուտքը թույլատրելու համար՝ այլ գործարքներին թույլ է տրվում կարդալ, սակայն չեն կարող կատարել փոփոխություններ տվյալների վրա:
- Տեսակ: Միջին մակարդակի արգելափակում է, որը թույլ է տալիս կարդալու գործողությունները, բայց չի թույլատրում փոփոխություններ:
- Օգտագործման դեպքեր: Կարդալու գործողություններ, օրինակ՝ հարցումներ (queries), որոնք տվյալներ չեն փոխում:
- Օրինակ. Գործարք 1-ը կարդում է տվյալները, բայց մյուս գործարքները նույնպես կարող են կարդալ դրանք, սակայն չեն կարող փոփոխություններ կատարել տվյալների վրա.


📂 <b>Արգելափակման մակարդակները (Locking Levels)</b>

1️⃣ <b>Row-level Locking (Տողերի մակարդակով արգելափակում)</b>
- Նպատակ: Արգելափակումը կիրառվում է միայն տվյալների բազայի մեկ տողի վրա, ինչը թույլ է տալիս մյուս տողերի վրա գործողություններ կատարել:
- Արդյունք: Մյուս գործարքները կարող են մուտք գործել և փոփոխություններ կատարել նույն աղյուսակի մյուս տողերի վրա, բայց այն տողը, որը արգելափակված է, մնում է պաշտպանված:
- Օգտագործման դեպքեր: Օգտագործվում է մեծ տոլերանտություն ունեցող համակարգերում, որտեղ պետք է թույլատրվեն միաժամանակյա փոփոխություններ տարբեր տողերում.

2️⃣ <b>Table-level Locking (Աղյուսակի մակարդակով արգելափակում)</b>
- Նպատակ: Արգելափակումն իրականացնում է ամբողջ աղյուսակի վրա, այն արգելափակում է ամբողջ աղյուսակն ու թույլ է տալիս միայն մեկ գործարքի կատարել փոփոխություններ:
- Արդյունք: Երբ աղյուսակը արգելափակվում է, այլ գործարքները չեն կարող ոչ կարդալ, ոչ գրել տվյալները տվյալ աղյուսակում:
- Օգտագործման դեպքեր: Օգտագործվում է ավելի փոքր, քիչ օգտագործվող աղյուսակներում, որտեղ միաժամանակյա մուտքեր չեն սպասվում.

3️⃣ <b>Page-level Locking (Էջի մակարդակով արգելափակում)</b>
- Նպատակ: Արգելափակում է տվյալների բազայի էջերը (page), ինչը թույլ է տալիս մուտք գործել տվյալներ միայն այդ էջի վրա, բայց թույլ չի տալիս մուտք գործել այլ էջերի տվյալները:
- Արդյունք: Մոտավորապես միաժամանակյա մուտքեր հնարավոր են, բայց սահմանափակվում են միայն որոշակի տվյալների բազայի էջով:
- Օգտագործման դեպքեր: Օգտագործվում է ավելի մեծ չափի բազաներում, որտեղ ամբողջ աղյուսակի արգելափակումն այնքան էլ արդյունավետ չէ.

4️⃣ <b>Database-level Locking (Տվյալների բազայի մակարդակով արգելափակում)</b>
- Նպատակ: Արգելափակում է ամբողջ տվյալների բազան, ինչի արդյունքում ոչ մի այլ գործարք չի կարող մուտք գործել տվյալների բազա:
- Արդյունք: Արգելափակումը վերաբերում է ամբողջ տվյալների բազային, ինչը ծնում է անբավարար արդյունավետություն մեծ բազաների դեպքում:
- Օգտագործման դեպքեր: Օգտագործվում է շատ հազվադեպ, երբ անհրաժեշտ է բացառիկ մուտք տվյալների բազայի ամբողջության վրա.

    """,
    "Տրանզակցիաների տեսակները։":
         """
📊 <b>Ավտոմատ (Autocommit) Տրանզակցիա</b>\n\n
Այս տրանզակցիաները կատարվում են ավտոմատ կերպով՝ առանց օգտատիրոջ միջամտության: Յուրաքանչյուր գործողություն ենթադրում է ավտոմատ տրանզակցիայի ավարտ և հաստատում: Եթե որևէ գործողություն հաջող է, ապա փոփոխությունները անմիջապես պահպանվում են տվյալների բազայում:\n\n
⚙️ <b>Բացահայտ (Explicit) Տրանզակցիա</b>\n
Բացահայտ տրանզակցիաները սկսվում են օգտատիրոջ կամ ծրագրի կողմից՝ հատուկ հրահանգով: Այս տրանզակցիաները պահանջում են օգտատիրոջ միջամտություն՝ սկսելու և ավարտելու համար, ինչպես նաև եթե ինչ-որ սխալ է տեղի ունենում, դրանք հնարավոր է հետ վերադարձնել:\n\n
📂 <b>Անբացահայտ (Implicit) Տրանզակցիա</b>\n
Այս տրանզակցիաները սկսվում են ավտոմատ, սակայն դրանք չեն պահանջում հատուկ հրահանգ: Դրանք տեղի են ունենում ցանկացած գործողության ժամանակ՝ օրինակ, եթե կատարվում է տվյալների փոփոխություն, ապա այդ փոփոխությունը ավտոմատ կերպով միտված կլինի որպես տրանզակցիա:\n\n
ℹ️ <b>Բաժանված (Distributed) Տրանզակցիա</b>\n
Բաժանված տրանզակցիաները կատարվում են մի քանի տարբեր համակարգերում կամ բազաներում: Այս տրանզակցիաներն իրականացվում են, երբ տվյալները գտնվել են տարբեր վայրերում կամ սերվերներում, և այս համակարգերը պետք է համակարգված աշխատեն միասին:\n\n
⚡️ <b>Ներդրված (Nested) Տրանզակցիա</b>\n\n
Ներդրված տրանզակցիաները վերաբերում են տրանզակցիաներին, որոնք ունեն ներքին ենթահամակարգեր կամ գործողություններ: Այս տրանզակցիաները սկսվում են հիմնական տրանզակցիայի մեջ, և եթե հիմնական տրանզակցիան չընդունվի, ներքին ենթահամակարգերի գործողությունները ևս անընդունելի են։
""",
    "Տրանզակցիաների մեկուսացման մակարդակները։":
"""
📊 <b>Տրանզակցիաների Մեկուսացում (Isolation)</b>\n\n
Տրանզակցիաների մեկուսացումը վերաբերում է այն երաշխիքին, որ մեկ տրանզակցիան կարող է կատարվել առանց interference-ի մյուս տրանզակցիաներից: Մեկուսացման մակարդակները սահմանում են, թե որքանով են տրանզակցիաները միմյանցից անկախ աշխատում, երբ դրանք միաժամանակ կատարում են տվյալների բազայում փոփոխություններ:\n\n
⚙️ <b>Ռելյացիոն տվյալների բազաների կառավարման համակարգերում (DBMS) ընդունված մեկուսացման մակարդակներ՝ ըստ SQL Standard:</b>\n\n
1️⃣ <b>Read Uncommitted (Անհավատարմագրված կարդալ)</b>\n
Այս մակարդակը թույլ է տալիս բոլոր տրանզակցիաներին կարդալ այն տվյալները, որոնք մյուս տրանզակցիաները դեռևս չեն հաստատել (չհավատարմագրված):\n
• Կազմակերպման մեջ՝ թույլ է տալիս կարդալ "մեջտեղի փոփոխությունները"՝ երբ մյուս տրանզակցիան դեռևս չի ավարտվել:\n
• Խնդիրներ՝ կարող է առաջանալ "Dirty Read" (գրադարձման կեղտոտ ընթերցում), երբ մեկ տրանզակցիայի փոփոխությունները կարդացվում են, մինչդեռ այն տրանզակցիան հետագայում կարող է չհաստատվել:\n\n
2️⃣ <b>Read Committed (Հավատարմագրված կարդալ)</b>\n
Այս մակարդակը թույլ է տալիս կարդալ միայն այն տվյալները, որոնք հաստատվել են (Committed): Դրա մեջ ներառվում է մյուս տրանզակցիաների հաստատված տվյալների միայն տեսանելիությունը:\n
• Կազմակերպման մեջ՝ համատեղում է անվտանգություն և կատարողականություն, բայց թույլ է տալիս միջանկյալ տվյալների փոփոխությունները:\n
• Խնդիրներ՝ կարող է առաջանալ "Non-repeatable Read" (չհաստատված ընթերցում), երբ տվյալները փոխվում են միաժամանակյա այլ տրանզակցիայի կողմից:\n\n
3️⃣ <b>Repeatable Read (Կրկնակի կարդալ)</b>\n
Այս մակարդակը երաշխավորում է, որ տվյալների վերականգնման ընթացքում մեկ տրանզակցիայի ընթերցումները միշտ նույնն են լինելու, նույնիսկ եթե այլ տրանզակցիաներ փոփոխություններ են կատարում տվյալներում:\n
• Կազմակերպման մեջ՝ կարդալու համար օգտագործվում են միայն այն տվյալները, որոնք սկզբում կարդացվել են:\n
• Խնդիրներ՝ "Phantom Read" (Անցանկալի կարդալ) կարող է տեղի ունենալ, երբ նոր տրանզակցիա ավելացնում է նոր գրառումներ, որոնք համապատասխանել են նախորդ հարցման պայմաններին:\n\n
4️⃣ <b>Serializable (Սերիալիզացվող)</b>\n
Սա ամենաբարձր մեկուսացման մակարդակն է, որը երաշխավորում է, որ բոլոր տրանզակցիաները կտրված են միմյանցից այնպես, որ նրանք պետք է կատարեն այնպիսի եղանակով, ասես դրանք հերթով կատարվում են՝ ոչ միաժամանակ:\n
• Կազմակերպման մեջ՝ ապահովում է ամբողջական մեկուսացում՝ բացառելով ցանկացած կոնֆլիկտներ։\n
• Խնդիրներ՝ կարող է նվազեցնել համակարգի կատարողականությունը, քանի որ ամեն մի տրանզակցիա կարող է սպասել մյուսին, եթե դրանք հետհետ գնան մեկ առանցքային ռեսուրսների վրա:\n\n
📂 <b>Snapshot Isolation (Սնափշոթ մեկուսացում)</b>\n
Snapshot Isolation-ը մի տեսակ մեկուսացման մակարդակ է, որը երաշխավորում է, որ յուրաքանչյուր տրանզակցիա միշտ կտեսնի տվյալների բազայի որոշակի «լուսանկար» (snapshot), երբ այն սկսվել է, և բոլոր փոփոխությունները, որոնք կատարվում են այդ տրանզակցիայում, չեն կարող ազդել այլ տրանզակցիաների կողմից կատարվող գործողությունների վրա մինչև այն ավարտվի:\n
• Կազմակերպման մեջ՝ տրանզակցիաները աշխատում են իրենց "լուսանկարի" վրա՝ երբ սկսվում է տվյալ տրանզակցիան, նրանք օգտագործում են այն ժամանակաշրջանի տվյալները, երբ այդ տրանզակցիան սկսել է:\n
• Խնդիրներ՝ երբ միաժամանակյա տրանզակցիաներ ավելացնում են նոր գրառումներ, կարող են առաջանալ Phantom Reads: Սույն մակարդակը չի կարող ապահովել, որ նոր տվյալները, որոնք ավելացվում են մեկ այլ տրանզակցիայի կողմից, չներկայացվեն որպես "phantoms" (առանց հիմքի):\n\n
""",
    "Linked Server: sp_ add_linkedserver համակարգային պրոցեդուրան։":
"""
<b>Linked Server-ը</b> OLE DB (Object Linking and Embedding, Database) տեխնոլոգիայի կիրառմամբ հնարավորություն է տալիս Transact-SQL-ի հրամաններով հասանելի դարձնել այլ միջավարերում ստեղծված տվյալների բազաները կամ էլեկտրոնային աղյուսակները 📊📂։ Linked server-ը կարգաբերվում է կամ SQL Server Management Studio –ում կամ Transact-SQL-ի sp_addlinkedserver հրամանով 🖥️։ OLE DB provider-ները տրամադրում են ռեսուրսների տարբեր հասանելիութուն՝ միայն ընթերցում 📖, փոփոխում 🔄 և այլն։ Linked Server-ը հայտարարելիս տրվում է:
• OLE DB provider-ը,
• OLE DB տվյալների աղբյուրը 📍։

OLE DB provider-ը տվյալների աղբյուրը ղեկավարող DLL է 💻։ OLE DB-ով հասանելի տվյալների աղբյուրը սովորաբար տվյալների բազա է (Dbase, Oracle, Access և այլն), սակայն կարող է ունենալ նաև այլ ձևաչափ 📁։ 

Linked Server-ը իրականացնում է բաժանված հարցումներ 🔍։ Կլիենտից հարցումը ստանալով SQL Server-ը այն փոխանցում է OLE DB-ին, որի կառավարմամբ էլ կատարվում են հրամանները ⬇️։ Հրամանային այս կառուցվածքներում օբյեկտներին դիմելիս անհրաժեշտ է կիրառել ամբողջական ձևաչափը՝ linked_server_name.catalog.schema.object_name 🧩

<b>sp_addlinkedserver-ը</b> SQL Server-ում օգտագործվող համակարգային պրոցեդուրան է 🛠️, որը թույլ է տալիս ստեղծել միավորված սերվերներ (linked servers) 🌐։ Linked Server-ը SQL Server-ի մեջ հնարավորություն է տալիս միացնել և հարցումներ կատարել այլ տվյալների բազաներից կամ համակարգերից, որոնք գտնվում են տարբեր սերվերներում 🔄։ Այս պրոցեդուրան օգտագործվում է, երբ ցանկանում ենք միանալ մեկ այլ SQL Server-ի կամ այլ տվյալների բազայի, օրինակ՝ Oracle, MySQL, Access կամ այլն 🌍։

<b>Սինտաքսը</b>:
<pre>
sp_addlinkedserver 
    @server = 'server_name',                -- Նշում է միացված սերվերի անունը
    @provider = 'provider_name',            -- Նշում է օգտագործվող պրովայդերի անունը (օրինակ՝ SQLNCLI, MSDASQL)
    @datasrc = 'data_source_name',          -- Նշում է տվյալների աղբյուրի անունը կամ սերվերի IP հասցեն
    @srvproduct = 'product_name',           -- (Optional) Կարգավորումը, եթե սերվերի արտադրողը տարբերվում է այնպիսի սերվերներից, որոնք արդեն կան
    @catalog = 'database_name';             -- (Optional) Տվյալների բազայի անուն (առավելապես SQL Server-ի համար)
</pre>

<b>Պարամետրերի բացատրություն</b>:
• <b>@server</b>: Սա այն անունն է, որը կհղվի սերվերին 📍: Օրինակ՝ MyLinkedServer 📌
• <b>@provider</b>: Սա այն պրովայդերն է, որը SQL Server-ը օգտագործում է մյուս տվյալների բազայի հետ միանալու համար 🔗: Այս պարամետրին սովորաբար նշանակվում է պրովայդերների անուններ, ինչպիսիք են SQLNCLI (SQL Server Native Client), MSDASQL (ODBC), OraOLEDB.Oracle (Oracle DB) և այլն 🖧:
• <b>@datasrc</b>: Սա այն տվյալների աղբյուրն է, որը նշում է կարդացվող տվյալների բազայի գտնվելու վայրը 📍, օրինակ՝ սերվերի անունը կամ IP հասցեն 🌐: Օրինակ՝ MyRemoteServer 💻
• <b>@srvproduct</b>: Եթե դա անհրաժեշտ է, այս պարամետրով նշվում է տվյալների բազայի արտադրողի անունը 📢, որը հնարավորություն է տալիս նշել, թե ինչ սերվերի վրա ենք աշխատում 📊: Դա սովորաբար չի պահանջվում, եթե սերվերը SQL Server է 🔒:
• <b>@catalog</b>: Սա տվյալների բազայի անունն է, եթե դուք ցանկանում եք կոնկրետ տվյալների բազայի հետ միանալ 🗂️:
""",
    "Openquery, Openrowset:":
"""
    <b>Openquery և Openrowset</b>  
Openquery և Openrowset SQL Server-ում օգտագործվող մեթոդներ են, որոնք թույլ են տալիս կատարել հարցումներ (queries) արտաքին տվյալների աղբյուրներին (Linked Servers)՝ առանց նախօրոք ստեղծելու տվյալների բազայի կապեր կամ միանալու տվյալների բազաներին 🔗.  
Այժմ կանդրադառնանք յուրաքանչյուրին:  

<b>1. Openquery</b>  
Openquery SQL Server-ի համակարգում օգտագործվող ֆունկցիա է, որը թույլ է տալիս կատարել հարցումներ արտաքին տվյալների աղբյուրներին (Linked Servers) SQL Server-ի միջոցով 🔍:

<b>Սինտաքսը</b>:  
<pre>
SELECT * 
FROM OPENQUERY (LinkedServer, 'query');
</pre>
• <b>LinkedServer</b>՝ Սա այն Linked Server-ի անունն է, որի հետ կցուցադրվի հարցումը 🌐.  
• <b>'query'</b>՝ Սա արտաքին տվյալների աղբյուրին ուղղված հարցումն է, որը պետք է ներմուծվի որպես տող 📋.

<b>Օրինակ:</b> Դիմելու համար Linked Server՝ RemoteSQLServer և ստանալու տվյալներ այն աղբյուրից:  
<pre>
SELECT * 
FROM OPENQUERY (RemoteSQLServer, 'SELECT Name, Age FROM Employees WHERE Age > 30');
</pre>
Այս հարցումը կկատարի հարցում RemoteSQLServer-ում գտնվող Employees աղյուսակում, որտեղ Age-ը ավելի մեծ է 30-ից 🧑‍💻.

<b>Հատկություններ:</b>  
• OPENQUERY-ը օգտագործում է արտաքին սերվերի լեզուն՝ կատարելու հարցումները, ինչը կարող է լինել SQL Server-ի վրա, բայց նաև կարող է լինել այլ տվյալների բազայի լեզու (օրինակ՝ Oracle կամ MySQL) 💻.  
• Այն վերադարձնում է միայն այն տվյալները, որոնք պահանջվում են արտաքին սերվերից 📈.

<b>2. Openrowset</b>  
Openrowset SQL Server-ի այլ մեթոդ է, որը թույլ է տալիս միանգամից հարցումներ կատարել տվյալների աղբյուրի վրա առանց նախապես Linked Server ստեղծելու ⚡.

<b>Սինտաքսը</b>:  
<pre>
SELECT * 
FROM OPENROWSET (provider_name, data_source, 'query');
</pre>
• <b>provider_name</b>՝ Անվանումն այն պրովայդերի, որը կապում է SQL Server-ը արտաքին տվյալների աղբյուրի հետ (օրինակ՝ SQLNCLI կամ MSDASQL) 🔗.  
• <b>data_source</b>՝ Տվյալների աղբյուրի հասցեն կամ ֆայլի տեղակայումը 📍.  
• <b>'query'</b>՝ Արտաքին տվյալների աղբյուրի վրա կատարվող հարցումը 📋.

<b>Օրինակ:</b> Միացման համար՝ RemoteSQLServer և հարցումը կատարելու համար Employees աղյուսակում:  
<pre>
SELECT * 
FROM OPENROWSET ('SQLNCLI', 'Server=RemoteSQLServer;Trusted_Connection=Yes;', 'SELECT Name, Age FROM Employees WHERE Age > 30');
</pre>
Այս հարցումը կկատարի նույն հարցումը, ինչպես նախորդը, բայց այստեղ ոչ մի Linked Server չկա, քանի որ ուղղակի հարցումն իրականացվում է՝ պրովայդերի միջոցով 🔄.

<b>Հատկություններ:</b>  
• OPENROWSET-ը ավելի հարմար է, երբ հարցումներ են կատարվում արտասովոր կամ մեկ անգամյա տվյալների աղբյուրների վրա, առանց Linked Server ստեղծելու ⚙️.  
• Այն նաև կարող է օգտագործվել արտաքին տվյալների աղբյուրից տվյալների ներմուծման կամ արտահանումների համար 🔄📤.  
• Մի քանի ձևաչափերի տվյալներ կարող են բացվել, ինչպիսիք են Excel կամ CSV ֆայլերը 📂📊.
    """,
    "Ինդեքսներ, դրանց կիրառման նպատակները։ Ինդեքսների տեսակները։ Ինդեքսների ստեղծումը։ Կլաստերացված ինդեքսներ։ Ոչ կլաստերացված ինդեքսներ։ Կլաստերացված և ոչ կլաստերացված ինդեքսների տարբերությունը։ Ունիկալ ինդեքսներ։":
    """
    <b>Ինդեքսներ՝</b> տվյալների բազայում համալիրված աղյուսակների տվյալները արագ որոնելու և մուտք գործելու մեթոդ են։ Իրականում ինդեքսը նման է մատյանի պարագծային ցանկի՝ այն նպաստում է տվյալների արագ հասանելիության և օպտիմիզացիայի ապահովմանը 📚.  

<b>Ինդեքսների Կիրառման Նպատակները:</b>  
1. <b>Արագ որոնում</b>՝ Ինդեքսները թույլ են տալիս արագ գտնել տվյալները աղյուսակում՝ նվազեցնելով անհրաժեշտ տվյալների որոնման ժամանակը ⏱.  
2. <b>Գումարային գործողություններ</b>՝ Ինդեքսները օպտիմիզացնում են աղյուսակների համար իրականացվող որոնման, խմբագրման, գործարկման և թարմացման գործողությունները 🔄.  
3. <b>Գործընթացների արդյունավետություն</b>՝ Փոքրացնելով տվյալների շտկման ժամանակը, ինդեքսները կարող են մեծացնել տվյալների բազայի համակարգի ընդհանուր արագությունը ⚡.  
4. <b>Պահպանման նվազեցում</b>՝ Ինդեքսները նվազեցնում են տվյալների բազայի ծավալը՝ ուղղակիորեն նվազեցնելով տվյալների բազայի աշխատանքի ծախսերը 💸.

<b>Ինդեքսների Տեսակները:</b>  
1. <b>Կլաստերացված ինդեքսներ (Clustered Indexes)</b>  
Կլաստերացված ինդեքսները փոփոխություն են կատարում տվյալների աղյուսակի ֆիզիկական դասավորության մեջ. Աղյուսակի տվյալները կազմակերպվում են ինդեքսի հիման վրա, ուստի յուրաքանչյուր աղյուսակում կարող է լինել միայն մեկ կլաստերացված ինդեքս 🏗.

2. <b>Ոչ կլաստերացված ինդեքսներ (Non-Clustered Indexes)</b>  
Ոչ կլաստերացված ինդեքսները տվյալների աղյուսակի ֆիզիկական դասավորությունը չեն փոխում. Դրանք տվյալների առանձին պատճեն են, որտեղ պահվում են տվյալների քանակները, իսկ ինդեքսը վերաբերում է տվյալների զանգվածին 🗂️.

3. <b>Ունիկալ ինդեքսներ (Unique Indexes)</b>  
Ունիկալ ինդեքսները ապահովում են, որ տվյալների աղյուսակում չունենա կրկնօրինակ գրառումներ՝ կանխելով կրկնակի տվյալների մուտքագրումը 🛑.

<b>Ինդեքսների Ստեղծումը:</b>  
Ինդեքսները ստեղծվում են SQL-ում CREATE INDEX հրամանի միջոցով:  
<b>Սինտաքսը:</b>  
<pre>
CREATE [UNIQUE] INDEX index_name
ON table_name (column_name);
</pre>
• <b>UNIQUE:</b> Եթե ցանկանում ենք, որ ինդեքսը լինի ունիկալ և չթույլատրի կրկնակի տվյալների մուտք։  
• <b>index_name:</b> Ինդեքսի անունը։  
• <b>table_name:</b> Ինդեքս ստեղծելու աղյուսակի անունը։  
• <b>column_name:</b> Տվյալների աղյուսակում ինդեքսավորված սյունը։

<b>Օրինակ:</b>  
<b>Կլաստերացված ինդեքսի ստեղծում:</b>  
<pre>
CREATE CLUSTERED INDEX idx_customer_id
ON Customers (CustomerID);
</pre>  
<b>Ոչ կլաստերացված ինդեքսի ստեղծում:</b>  
<pre>
CREATE NONCLUSTERED INDEX idx_customer_name
ON Customers (CustomerName);
</pre>

<b>Կլաստերացված Ինդեքսներ:</b>  
Կլաստերացված ինդեքսը տվյալների աղյուսակի ֆիզիկական դասավորության մեջ կատարում է փոփոխություն։ Այս ինդեքսը հիմնված է տվյալների արտահայտման վրա, որը նշանակում է, որ տվյալները տեղավորվում են ինդեքսի կառուցվածքում 🏗️.

<b>Հատկություններ:</b>  
• Յուրաքանչյուր աղյուսակ կարող է ունենալ միայն մեկ կլաստերացված ինդեքս, քանի որ տվյալների ֆիզիկական դասավորությունը մեկ անգամից ավելի փոխել չի կարելի ⚠️.  
• Կլաստերացված ինդեքսը օգտագործվում է այն սյուների համար, որոնք հաճախ օգտագործվում են որպես որոնման հիմնական (primary) կամ եզակի (unique) կոդեր 🔑.

<b>Օրինակ:</b>  
<pre>
CREATE CLUSTERED INDEX idx_customer_id
ON Customers (CustomerID);
</pre>

<b>Ոչ Կլաստերացված Ինդեքսներ:</b>  
Ոչ կլաստերացված ինդեքսը տվյալների աղյուսակի ֆիզիկական դասավորությունը չի փոխում։ Այն պարզապես ստեղծում է ալիքային կառուցվածք, որտեղ տվյալները պահվում են կորպուսի կամ ինդեքսի մեջ, որը հատուկ կազմակերպում է տվյալների որոնումը 📚.

<b>Հատկություններ:</b>  
• Աղյուսակը կարող է ունենալ բազմաթիվ ոչ կլաստերացված ինդեքսներ 📊.  
• Ոչ կլաստերացված ինդեքսը օգտագործվում է այն սյուների համար, որոնք պահանջում են հաճախակի որոնումներ կամ հարցումներ 🔍.

<b>Օրինակ:</b>  
<pre>
CREATE NONCLUSTERED INDEX idx_customer_name
ON Customers (CustomerName);
</pre>

<b>Ունիկալ Ինդեքսներ:</b>  
Ունիկալ ինդեքսները ապահովում են, որ տվյալների աղյուսակում չունենա կրկնօրինակ գրառումներ։ Եթե տվյալների նոր գրառում ներառի կրկնակի արժեքներ, ապա ինդեքսը կհանգեցնի սխալի ⚠️.

<b>Օրինակ:</b>  
<pre>
CREATE UNIQUE INDEX idx_unique_email
ON Customers (Email);
</pre>
Այս ինդեքսը ապահովում է, որ յուրաքանչյուր հաճախորդի էլ. փոստի հասցեն լինի միայն մեկ անգամ տվյալների բազայում 📧.

    """,
"Ինդեքսների կազմակերպումը և պահպանումը սկավառակի վրա։ Բազմամակարդակ ինդեքսավորում։ m-way փնտրում։ B tree, ձևավորման կանոնները։ B tree-ում և B+ tree-ում կապը տվյալների հետ։ B+ tree։":
    """
    📊 <b>Ինդեքսներ</b>
Ինդեքսները տվյալների բազայում ապահովում են արագ որոնման և մուտքի հնարավորություն: Դրանք կազմակերպվում են այնպես, որ հնարավոր լինի արագորեն ստանալ արդյունք հարցումներից՝ առանց ամբողջ աղյուսակի տվյալները վերանայելու. 🔍

⚙️ <b>Ինդեքսների Կազմակերպում</b>
Ինդեքսները կազմակերպվում են սկավառակի վրա՝ որպես առանձին ֆայլեր կամ տվյալների բազայի մասեր, որոնք պարունակում են ինդեքսավորված սյուների արժեքները և դրանց հղումները (փենդինգներ) դեպի տվյալները: 🗂️ Նրանք պահպանում են տվյալների որոնման կառուցվածքները (հաճախ树-like) ու կազմակերպում են դրանք հատուկ պատճենների տեսքով: 

📂 <b>Բազմամակարդակ Ինդեքսավորում (Multilevel Indexing)</b>
Բազմամակարդակ ինդեքսավորումը օգտագործվում է այն դեպքում, երբ ինդեքսը այնքան մեծ է, որ չի fits մեկ մակարդակում: Սա առաջացնում է ինդեքսների մի շարք մակարդակներ, որտեղ յուրաքանչյուր մակարդակ կուտակում է բարձր մակարդակի ինդեքսը ներքևի ինդեքսների վրա:
1. Առաջին մակարդակի ինդեքսը ցույց է տալիս, թե որտեղ են տեղադրված տվյալները երկրորդ մակարդակում.
2. Երկրորդ մակարդակի ինդեքսները, իրենց հերթին, կազմակերպում են տվյալները ավելի մանրամասն:  
Այս համակարգը կարող է լինել բարդ, բայց այն օգնում է խուսափել մեծ ինդեքսների հետ աշխատանքից, որոնք կարող են լինել շատ ծանր: ⚖️

⚡️ <b>M-way փնտրում</b>
M-way փնտրումը օգտագործում է ծառի նման կառուցվածքներ, որտեղ յուրաքանչյուր հանգույց կարող է պարունակել ավելի քան երկու երեխա։ M-ը նշում է երեխայի հնարավոր քանակը, որը կազմում է տվյալների որոնման ալգորիթմը: Այս մոտեցումն ավելի է մեծացնում փնտրումի արդյունավետությունը՝ հատակագրված ինդեքսային ծառերի միջոցով:

📈 <b>B-Tree, ձևավորման կանոնները</b>
B-Tree (Balanced Tree) այն ինքնաբալանսավորված ինդեքսային ծառերից է, որն ապահովում է արագ որոնում, ներառում, հեռացում, և թարմացում: Բառացիորեն, B-Tree-ն ապահովում է հավասարակշռված պահպանում այդպիսի անընդհատ գործողություններում:

1. <b>Բալանսավորվածություն:</b> B-Tree-ն պետք է լինի բալանսավորված, այսինքն՝ նրա բոլոր տերևային հանգույցները պետք է լինեն նույն մակարդակում:
2. <b>Հանգույցի առավելագույն և նվազագույն տիրույթ:</b> Միջակողմանի հանգույցը կարող է պարունակել նիշեր, որոնք սահմանված են ծառի կարգի (order) վրա:
   - Քանի որ յուրաքանչյուր հանգույցը կարող է պարունակել բազմաթիվ կլիչեր, այն բաժանվում է որոշակի թվի ներքևում:
3. <b>Որպես ինդեքսներ:</b> B-tree-ը պարունակում է ինդեքսների միջոցով հարցումներ, որոնք ապահովում են տվյալների շտապ մուտք:

    """,
"Hash աղյուսակներ։ Hashing ալգորիթմ։ Բախում հասկացությունը։ «Բաց» հասցեավորում՝ գծային զոնդավորումը (linear probing)։ «Բաց» հասցեավորման plus 3 rehash, quadratic probing, double hashing մեխանիզմները։ Շղթայական (chaining) կամ կից հասցեավորումը (closed addressing)։ Hash ֆունկցիայի նպատակները։":
"""
📊 <b>Hash Աղյուսակներ</b>
Hash աղյուսակները տվյալների կառուցվածք են, որոնք նախատեսված են արդյունավետ կերպով տվյալներ որոնելու, ավելացնելու և հեռացնելու համար: Այս համակարգի հիմնական գաղափարը տվյալները կոդավորելու մեջ է, որը տալիս է եզակի ինդեքս (հաշվարկված հասցե) տվյալների համար, որը կոչվում է hash address: Այսպիսով, տվյալները հեշտությամբ հասանելի են ինդեքսի միջոցով, առանց անհրաժեշտության ամբողջ աղյուսակը հետազոտելու: 

⚙️ <b>Hashing Ալգորիթմ</b>
Hashing-ը գործընթաց է, որտեղ տվյալները կամ օբյեկտները վերափոխվում են երկարության ֆիքսված արժեքների՝ սովորաբար ամբողջական թվերի, որն կոչվում է hash value կամ hash code: Այս արժեքը հետագայում օգտագործվում է տվյալների որոնման համար աղյուսակում:
Hash ֆունկցիան մի ֆունկցիա է, որը յուրաքանչյուր մուտքային տվյալների վրա կատարելով որոշակի հաշվարկ՝ այն վերածում է մի ամբողջ թիվ, որն ապահովում է տվյալների տեղադրման հասցեն աղյուսակում: 

📂 <b>Բախում (Collision) Հասկացությունը</b>
Բախումը տեղի է ունենում, երբ երկու կամ ավելի արժեքներ, որոնք առաջացել են տարբեր մուտքային տվյալներից, ունեն նույն hash address-ը: Այս երևույթը սովորական է hash աղյուսակներում, քանի որ հնարավոր է, որ տարբեր տվյալներ հանգեն նույն hash արժեքին:

🔧 <b>Բաց Հասցեավորում (Open Addressing)</b>
«Բաց» հասցեավորումը մեթոդ է, որի դեպքում բախման դեպքում որոշվում է հաջորդ ազատ տեղը աղյուսակում՝ փորձելով գտնել կարճատև տեղադրում:
Գծային զոնդավորում (Linear Probing) մեթոդը մեկն է այս մոտեցումների մեջ:
• Գծային զոնդավորում: Այս մեթոդում, երբ բախում է տեղի ունենում, hash աղյուսակում կատարվում է հաջորդ վելիդ տեղը որոնումը՝ ըստ սկզբնական հասցեի: Եթե արհեստականորեն ավելացված տարրը բախում է ստեղծում, որոնման հաբիզը տեղափոխվում է մեկ քայլով առաջ, մինչև գտնվի ազատ տեղ:
Օրինակ: Եթե տարրը նետվում է վայրի A հասցեում, և այնտեղ արդեն կա տարր, մենք կփորձենք A+1, A+2 և այլն:

🔄 <b>Բաց Հասցեավորման Plus 3 Rehash, Quadratic Probing, Double Hashing Մեխանիզմները</b>
1. Բաց հասցեավորման plus 3 rehash: Այս մեթոդում, երբ առաջին բախումը տեղի է ունենում, աղյուսակը տեղափոխում է տվյալը մի ուրիշ հորիզոնական վայրում։ Սա տեղի է ունենում խճճվածությունը նվազեցնելու համար, քանի որ այն սկսում է նորից հաշվարկել hash ֆունկցիան +3 տարբերությամբ:
2. Quadratic Probing: Այս մեթոդում բախման ժամանակ հաջորդ կետը որոնվում է քառակուսի երկարությամբ քայլերով: Մասնավորապես, եթե h(x) սկզբնական hash հասցեն է, ապա հաջորդ հասցենը կլինի h(x) + 1^2, ապա h(x) + 2^2 և այդպես շարունակ:
   o Այս մոտեցումը նվազեցնում է ցցվելության հավանականությունը (clustering), որը կարող է առաջանալ գծային զոնդավորման դեպքում:
3. Double Hashing: Այս մեթոդը կիրառվում է այն ժամանակ, երբ բախում է տեղի ունենում, իսկ hash ֆունկցիայի արդյունքը կրկնվում է: Երկրորդ hash ֆունկցիան հաշվում է նոր հասցե, որտեղ կտրված է դաշտի սկիզբը և շարունակում է որոնումը:
   o Նպատակը փախուստ է առաջանում հիմնականում երկարաշարքային տիպիկ բախումների դեպքում:

🔗 <b>Շղթայական (Chaining) կամ Կից Հասցեավորումը (Closed Addressing)</b>
Շղթայական հասցեավորումը կամ closed addressing-ը ալգորիթմ է, որտեղ բախման դեպքում յուրաքանչյուր ինդեքսում պահվում է տվյալների մի շղթա (Linked List): Այս մեթոդը թույլ է տալիս ունենալ բազմաթիվ տվյալներ նույն hash հասցեում:
• Բախման դեպքում տվյալները պարզապես ավելացվում են համապատասխան ինդեքսի «շղթայում»:
• Այս մոտեցումը ավելի արդյունավետ է, քան «բաց» հասցեավորումը, եթե աղյուսակը շատ շատ տարրեր պարունակի:
Օրինակ: Եթե երկու տարրեր ունեն նույն hash հասցեն, դրանք երկու տարբեր տարրեր կլինեն նույն ինդեքսում՝ միմյանց հետ կապված շղթայով:

📈 <b>Hash Ֆունկցիայի Նպատակները</b>
Hash ֆունկցիայի հիմնական նպատակներն են:
1. Ավելի արագ որոնում: Դրանով հասանելի են տվյալները առանց ամբողջ աղյուսակների հետազոտման:
2. Համակարգում ամբոություն: Մատչելիության բարձրացումը կանխելու համար hash ֆունկցիան պետք է բարձր արդյունավետություն ապահովի.
3. Տեղադրման և որոնման օպտիմիզացում: Hash ֆունկցիան պետք է նվազեցնի բախումները և պահի աղյուսակը կազմակերպված, որպեսզի հարցումները արագ կատարվեն:
4. Բախումների նվազեցում: Սեփական հատկությունները ապահովելու նպատակով hash ֆունկցիան պետք է համադրվի տարբեր լրացուցիչ մեթոդներով (quadratic probing, chaining և այլն):
Հակառակ դեպքում, եթե hash ֆունկցիան վատորեն ձևավորվի, աղյուսակը կարող է կուտակվել մեծ բախումներ և դանդաղեցնելու հարցումների կատարումը:
"""
}


buttons = [
    "Տվյալ, Տվյալների բազաներ, տվյալների բազաների կառավարման համակարգեր։",
    "Տվյալների բազաների մոդելները։",
    "Տվյալների բազաներին ներկայացվող պահանջները:",
    "Տվյալների բազաների կառավարման համակարգերում ACID-ը։",
    "Ռելյացիոն բազաներ՝ աղյուսակների հատկանիշները։",
    "Ռելյացիոն բազաներում կապերի տեսակները։",
    "Նորմալացում, նորմալացման I կանոնը։",
    "Նորմալացում, նորմալացման II կանոնը։",
    "Նորմալացում, նորմալացման III կանոնը։",
    "Տվյալներին միաժամանակյա հասնելիության խնդիրներ",
    "Արգելափակում։ Արգելափակման մակարդակները։",
    "Տրանզակցիաների տեսակները։",
    "Տրանզակցիաների մեկուսացման մակարդակները։",
    "Linked Server: sp_ add_linkedserver համակարգային պրոցեդուրան։",
    "Openquery, Openrowset:",
    "Ինդեքսներ, դրանց կիրառման նպատակները։",
    "Ինդեքսների կազմակերպումը և պահպանումը սկավառակի վրա։",
    "Hash աղյուսակներ։ Hashing ալգորիթմ։ Բախում հասկացությունը։"
]



import telebot
from telebot.types import ReplyKeyboardMarkup
# Ձեր բոտի տոկենը
API_TOKEN = '7812550423:AAF7COLqIoq2PDi-D6lidpopebhsnHSM70s'
bot = telebot.TeleBot(API_TOKEN)

markup = ReplyKeyboardMarkup()
for i in buttons:
    markup.add(i)

@bot.message_handler(commands=["start"])
def start(message: telebot.types.Message):
    bot.send_message(chat_id=message.chat.id, text="Ուղարկեք ձեր հարցը", reply_markup=markup)

@bot.message_handler(func=lambda message: True)
def answer(message: telebot.types.Message):
    for key in answers_dict:
        if key.lower().startswith(message.text.lower()):
            bot.send_message(chat_id=message.chat.id, text=f" {answers_dict[key]}", parse_mode="HTML")


bot.infinity_polling()
